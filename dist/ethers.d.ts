// Generated by dts-bundle v0.7.3

declare module 'ethers' {
    import { Contract, Interface } from 'ethers/contracts';
    import * as providers from 'ethers/providers';
    import * as errors from 'ethers/utils/errors';
    import { getNetwork } from 'ethers/providers/networks';
    import * as utils from 'ethers/utils';
    import { HDNode, SigningKey, Wallet } from 'ethers/wallet';
    import * as wordlists from 'ethers/wordlists';
    import { version } from 'ethers/_version';
    export { Wallet, HDNode, SigningKey, Contract, Interface, getNetwork, providers, errors, utils, wordlists, version };
    const _default: {
        Wallet: typeof Wallet;
        HDNode: typeof HDNode;
        SigningKey: typeof SigningKey;
        Contract: typeof Contract;
        Interface: typeof Interface;
        getNetwork: typeof getNetwork;
        providers: typeof providers;
        errors: typeof errors;
        utils: typeof utils;
        wordlists: typeof wordlists;
        version: string;
    };
    export default _default;
}

declare module 'ethers/contracts' {
    import { Contract } from 'ethers/contracts/contract';
    import { Interface } from 'ethers/contracts/interface';
    export { Contract, Interface };
    const _default: {
        Contract: typeof Contract;
        Interface: typeof Interface;
    };
    export default _default;
}

declare module 'ethers/providers' {
    import { Provider, ProviderSigner } from 'ethers/providers/provider';
    import { Network } from 'ethers/providers/networks';
    import { EtherscanProvider } from 'ethers/providers/etherscan-provider';
    import { FallbackProvider } from 'ethers/providers/fallback-provider';
    import { IpcProvider } from 'ethers/providers/ipc-provider';
    import { InfuraProvider } from 'ethers/providers/infura-provider';
    import { JsonRpcProvider } from 'ethers/providers/json-rpc-provider';
    import { Web3Provider } from 'ethers/providers/web3-provider';
    function getDefaultProvider(network?: Network | string): FallbackProvider;
    export { Provider, getDefaultProvider, ProviderSigner, FallbackProvider, EtherscanProvider, InfuraProvider, JsonRpcProvider, Web3Provider, IpcProvider };
    const _default: {
        Provider: typeof Provider;
        getDefaultProvider: typeof getDefaultProvider;
        ProviderSigner: typeof ProviderSigner;
        FallbackProvider: typeof FallbackProvider;
        EtherscanProvider: typeof EtherscanProvider;
        InfuraProvider: typeof InfuraProvider;
        JsonRpcProvider: typeof JsonRpcProvider;
        Web3Provider: typeof Web3Provider;
        IpcProvider: typeof IpcProvider;
    };
    export default _default;
}

declare module 'ethers/utils/errors' {
    export const UNKNOWN_ERROR = "UNKNOWN_ERROR";
    export const NOT_IMPLEMENTED = "NOT_IMPLEMENTED";
    export const MISSING_NEW = "MISSING_NEW";
    export const CALL_EXCEPTION = "CALL_EXCEPTION";
    export const INVALID_ARGUMENT = "INVALID_ARGUMENT";
    export const MISSING_ARGUMENT = "MISSING_ARGUMENT";
    export const UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT";
    export const NUMERIC_FAULT = "NUMERIC_FAULT";
    export const UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION";
    export function throwError(message: string, code: string, params: any): never;
    export function checkNew(self: any, kind: any): void;
}

declare module 'ethers/providers/networks' {
    export type Network = {
        name: string;
        chainId: number;
        ensAddress?: string;
    };
    export type Networkish = Network | string | number;
    /**
      *  getNetwork
      *
      *  Converts a named common networks or chain ID (network ID) to a Network
      *  and verifies a network is a valid Network..
      */
    export function getNetwork(network: Networkish): Network;
}

declare module 'ethers/utils' {
    import { getAddress, getContractAddress, getIcapAddress } from 'ethers/utils/address';
    import { AbiCoder, defaultAbiCoder, parseSignature, parseParamType } from 'ethers/utils/abi-coder';
    import * as base64 from 'ethers/utils/base64';
    import { BigNumber, bigNumberify } from 'ethers/utils/bignumber';
    import { arrayify, concat, hexlify, joinSignature, padZeros, splitSignature, stripZeros } from 'ethers/utils/bytes';
    import { hashMessage, id, namehash } from 'ethers/utils/hash';
    import { keccak256 } from 'ethers/utils/keccak256';
    import { sha256 } from 'ethers/utils/sha2';
    import { keccak256 as solidityKeccak256, pack as solidityPack, sha256 as soliditySha256 } from 'ethers/utils/solidity';
    import { randomBytes } from 'ethers/utils/random-bytes';
    import { defineFrozen, defineReadOnly, resolveProperties, shallowCopy } from 'ethers/utils/properties';
    import * as RLP from 'ethers/utils/rlp';
    import { toUtf8Bytes, toUtf8String } from 'ethers/utils/utf8';
    import { formatEther, parseEther, formatUnits, parseUnits } from 'ethers/utils/units';
    import { fetchJson } from 'ethers/utils/web';
    import { parse as parseTransaction } from 'ethers/utils/transaction';
    import * as errors from 'ethers/utils/errors';
    const etherSymbol = "\u039E";
    export { AbiCoder, defaultAbiCoder, parseSignature, parseParamType, RLP, fetchJson, defineReadOnly, defineFrozen, resolveProperties, shallowCopy, etherSymbol, arrayify, concat, padZeros, stripZeros, base64, bigNumberify, BigNumber, hexlify, toUtf8Bytes, toUtf8String, hashMessage, namehash, id, getAddress, getIcapAddress, getContractAddress, formatEther, parseEther, formatUnits, parseUnits, keccak256, sha256, randomBytes, solidityPack, solidityKeccak256, soliditySha256, splitSignature, joinSignature, parseTransaction, errors };
    const _default: {
        AbiCoder: typeof AbiCoder;
        defaultAbiCoder: AbiCoder;
        parseSignature: typeof parseSignature;
        parseParamType: typeof parseParamType;
        RLP: typeof RLP;
        fetchJson: typeof fetchJson;
        defineReadOnly: typeof defineReadOnly;
        defineFrozen: typeof defineFrozen;
        resolveProperties: typeof resolveProperties;
        shallowCopy: typeof shallowCopy;
        etherSymbol: string;
        arrayify: typeof arrayify;
        concat: typeof concat;
        padZeros: typeof padZeros;
        stripZeros: typeof stripZeros;
        base64: typeof base64;
        bigNumberify: typeof bigNumberify;
        BigNumber: typeof BigNumber;
        hexlify: typeof hexlify;
        toUtf8Bytes: typeof toUtf8Bytes;
        toUtf8String: typeof toUtf8String;
        hashMessage: typeof hashMessage;
        namehash: typeof namehash;
        id: typeof id;
        getAddress: typeof getAddress;
        getIcapAddress: typeof getIcapAddress;
        getContractAddress: typeof getContractAddress;
        formatEther: typeof formatEther;
        parseEther: typeof parseEther;
        formatUnits: typeof formatUnits;
        parseUnits: typeof parseUnits;
        keccak256: typeof keccak256;
        sha256: typeof sha256;
        randomBytes: typeof randomBytes;
        solidityPack: typeof solidityPack;
        solidityKeccak256: typeof solidityKeccak256;
        soliditySha256: typeof soliditySha256;
        splitSignature: typeof splitSignature;
        joinSignature: typeof joinSignature;
        parseTransaction: typeof parseTransaction;
        errors: typeof errors;
    };
    export default _default;
}

declare module 'ethers/wallet' {
    import { Wallet } from 'ethers/wallet/wallet';
    import * as HDNode from 'ethers/wallet/hdnode';
    import { SigningKey } from 'ethers/wallet/signing-key';
    export { HDNode, SigningKey, Wallet };
    const _default: {
        HDNode: typeof HDNode;
        SigningKey: typeof SigningKey;
        Wallet: typeof Wallet;
    };
    export default _default;
}

declare module 'ethers/wordlists' {
    import { Wordlist } from 'ethers/wordlists/wordlist';
    const en: Wordlist;
    const ko: Wordlist;
    const it: Wordlist;
    const ja: Wordlist;
    const zh: Wordlist;
    const zh_cn: Wordlist;
    const zh_tw: Wordlist;
    export { en, it, ja, ko, zh, zh_cn, zh_tw };
    const _default: {
        en: Wordlist;
        it: Wordlist;
        ja: Wordlist;
        ko: Wordlist;
        zh: Wordlist;
        zh_cn: Wordlist;
        zh_tw: Wordlist;
    };
    export default _default;
}

declare module 'ethers/_version' {
    export const version = "4.0.0";
}

declare module 'ethers/contracts/contract' {
    import { Interface } from 'ethers/contracts/interface';
    import { Provider, TransactionRequest, TransactionResponse } from 'ethers/providers/provider';
    import { Signer } from 'ethers/wallet/wallet';
    import { ParamType } from 'ethers/utils/abi-coder';
    import { BigNumber } from 'ethers/utils/bignumber';
    export type ContractEstimate = (...params: Array<any>) => Promise<BigNumber>;
    export type ContractFunction = (...params: Array<any>) => Promise<any>;
    export type ContractEvent = (...params: Array<any>) => void;
    interface Bucket<T> {
        [name: string]: T;
    }
    export type ErrorCallback = (error: Error) => void;
    export type Contractish = Array<string | ParamType> | Interface | string;
    export class Contract {
        readonly address: string;
        readonly interface: Interface;
        readonly signer: Signer;
        readonly provider: Provider;
        readonly estimate: Bucket<ContractEstimate>;
        readonly functions: Bucket<ContractFunction>;
        readonly events: Bucket<ContractEvent>;
        readonly addressPromise: Promise<string>;
        readonly deployTransaction: TransactionResponse;
        constructor(addressOrName: string, contractInterface: Contractish, signerOrProvider: Signer | Provider);
        onerror: ErrorCallback;
        fallback(overrides?: TransactionRequest): Promise<TransactionResponse>;
        connect(signerOrProvider: Signer | Provider): Contract;
        deploy(bytecode: string, ...args: Array<any>): Promise<Contract>;
    }
    export {};
}

declare module 'ethers/contracts/interface' {
    import { EventFragment, FunctionFragment, ParamType } from 'ethers/utils/abi-coder';
    import { BigNumber, BigNumberish } from 'ethers/utils/bignumber';
    export class Description {
        readonly type: string;
        constructor(info: any);
    }
    export class Indexed extends Description {
        readonly hash: string;
    }
    export class DeployDescription extends Description {
        readonly inputs: Array<ParamType>;
        readonly payable: boolean;
        encode(bytecode: string, params: Array<any>): string;
    }
    export class FunctionDescription extends Description {
        readonly name: string;
        readonly signature: string;
        readonly sighash: string;
        readonly inputs: Array<ParamType>;
        readonly outputs: Array<ParamType>;
        readonly payable: boolean;
        encode(params: Array<any>): string;
        decode(data: string): any;
    }
    export class EventDescription extends Description {
        readonly name: string;
        readonly signature: string;
        readonly inputs: Array<ParamType>;
        readonly anonymous: boolean;
        readonly topic: string;
        decode(data: string, topics?: Array<string>): any;
    }
    class TransactionDescription extends Description {
        readonly name: string;
        readonly args: Array<any>;
        readonly signature: string;
        readonly sighash: string;
        readonly decode: (data: string) => any;
        readonly value: BigNumber;
    }
    class LogDescription extends Description {
        readonly name: string;
        readonly signature: string;
        readonly topic: string;
        readonly values: Array<any>;
    }
    export class Interface {
        readonly abi: Array<EventFragment | FunctionFragment>;
        readonly functions: {
            [name: string]: FunctionDescription;
        };
        readonly events: {
            [name: string]: EventDescription;
        };
        readonly deployFunction: DeployDescription;
        constructor(abi: Array<string | ParamType> | string);
        parseTransaction(tx: {
            data: string;
            value?: BigNumberish;
        }): TransactionDescription;
        parseLog(log: {
            topics: Array<string>;
            data: string;
        }): LogDescription;
    }
    export {};
}

declare module 'ethers/providers/provider' {
    import { Signer } from 'ethers/wallet/wallet';
    import { BigNumber, BigNumberish } from 'ethers/utils/bignumber';
    import { Arrayish } from 'ethers/utils/bytes';
    import { Network, Networkish } from 'ethers/providers/networks';
    import { SignDigestFunc, Transaction } from 'ethers/utils/transaction';
    export type BlockTag = string | number;
    export interface Block {
        hash: string;
        parentHash: string;
        number: number;
        timestamp: number;
        nonce: string;
        difficulty: number;
        gasLimit: BigNumber;
        gasUsed: BigNumber;
        miner: string;
        extraData: string;
        transactions: Array<string>;
    }
    export type TransactionRequest = {
        to?: string | Promise<string>;
        from?: string | Promise<string>;
        nonce?: number | string | Promise<number | string>;
        gasLimit?: BigNumberish | Promise<BigNumberish>;
        gasPrice?: BigNumberish | Promise<BigNumberish>;
        data?: Arrayish | Promise<Arrayish>;
        value?: BigNumberish | Promise<BigNumberish>;
        chainId?: number | Promise<number>;
    };
    export interface TransactionResponse extends Transaction {
        blockNumber?: number;
        blockHash?: string;
        timestamp?: number;
        from: string;
        wait: (timeout?: number) => Promise<TransactionResponse>;
    }
    export interface TransactionReceipt {
        contractAddress?: string;
        transactionIndex?: number;
        root?: string;
        gasUsed?: BigNumber;
        logsBloom?: string;
        blockHash?: string;
        transactionHash?: string;
        logs?: Array<Log>;
        blockNumber?: number;
        cumulativeGasUsed?: BigNumber;
        byzantium: boolean;
        status?: number;
    }
    export type Filter = {
        fromBlock?: BlockTag;
        toBlock?: BlockTag;
        address?: string;
        topics?: Array<any>;
    };
    export interface Log {
        blockNumber?: number;
        blockHash?: string;
        transactionIndex?: number;
        removed?: boolean;
        transactionLogIndex?: number;
        address: string;
        data?: string;
        topics?: Array<string>;
        transactionHash?: string;
        logIndex?: number;
    }
    export type Listener = (...args: Array<any>) => void;
    export function checkTransactionResponse(transaction: any): TransactionResponse;
    export class ProviderSigner extends Signer {
        readonly provider: Provider;
        readonly signDigest: SignDigestFunc;
        constructor(address: string | Promise<string>, signDigest: SignDigestFunc, provider: Provider);
        getAddress(): Promise<string>;
        signMessage(message: Arrayish | string): Promise<string>;
        sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse>;
    }
    export class Provider {
        protected _emitted: any;
        /**
          *  ready
          *
          *  A Promise<Network> that resolves only once the provider is ready.
          *
          *  Sub-classes that call the super with a network without a chainId
          *  MUST set this. Standard named networks have a known chainId.
          *
          */
        protected ready: Promise<Network>;
        constructor(network: Networkish | Promise<Network>);
        resetEventsBlock(blockNumber: number): void;
        readonly network: Network;
        getNetwork(): Promise<Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        waitForTransaction(transactionHash: string, timeout?: number): Promise<TransactionResponse>;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<BigNumber>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
        getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
        call(transaction: TransactionRequest): Promise<string>;
        estimateGas(transaction: TransactionRequest): Promise<BigNumber>;
        getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
        getTransaction(transactionHash: string): Promise<TransactionResponse>;
        getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;
        getLogs(filter: Filter): Promise<Array<Log>>;
        getEtherPrice(): Promise<number>;
        _resolveNames(object: any, keys: Array<string>): Promise<{
            [key: string]: string;
        }>;
        _getResolver(name: string): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string>;
        lookupAddress(address: string | Promise<string>): Promise<string>;
        doPoll(): void;
        perform(method: string, params: any): Promise<any>;
        _startPending(): void;
        _stopPending(): void;
        on(eventName: any, listener: Listener): Provider;
        once(eventName: any, listener: Listener): Provider;
        emit(eventName: any, ...args: Array<any>): boolean;
        listenerCount(eventName?: any): number;
        listeners(eventName: any): Array<Listener>;
        removeAllListeners(eventName: any): Provider;
        removeListener(eventName: any, listener: Listener): Provider;
    }
}

declare module 'ethers/providers/etherscan-provider' {
    import { BlockTag, Provider, TransactionResponse } from 'ethers/providers/provider';
    import { Networkish } from 'ethers/providers/networks';
    export class EtherscanProvider extends Provider {
        readonly baseUrl: string;
        readonly apiKey: string;
        constructor(network?: Networkish, apiKey?: string);
        perform(method: string, params: any): Promise<any>;
        getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>>;
    }
}

declare module 'ethers/providers/fallback-provider' {
    import { Provider } from 'ethers/providers/provider';
    export class FallbackProvider extends Provider {
        constructor(providers: Array<Provider>);
        readonly providers: Array<Provider>;
        perform(method: string, params: any): any;
    }
}

declare module 'ethers/providers/ipc-provider' {
    import { JsonRpcProvider } from 'ethers/providers/json-rpc-provider';
    import { Networkish } from 'ethers/providers/networks';
    export class IpcProvider extends JsonRpcProvider {
        readonly path: string;
        constructor(path: string, network?: Networkish);
        send(method: string, params: any): Promise<any>;
    }
}

declare module 'ethers/providers/infura-provider' {
    import { JsonRpcProvider, JsonRpcSigner } from 'ethers/providers/json-rpc-provider';
    import { Networkish } from 'ethers/providers/networks';
    export class InfuraProvider extends JsonRpcProvider {
        readonly apiAccessToken: string;
        constructor(network?: Networkish, apiAccessToken?: string);
        _startPending(): void;
        getSigner(address?: string): JsonRpcSigner;
        listAccounts(): Promise<Array<string>>;
    }
}

declare module 'ethers/providers/json-rpc-provider' {
    import { Networkish } from 'ethers/providers/networks';
    import { BlockTag, Provider, TransactionRequest, TransactionResponse } from 'ethers/providers/provider';
    import { Signer } from 'ethers/wallet/wallet';
    import { BigNumber } from 'ethers/utils/bignumber';
    import { Arrayish } from 'ethers/utils/bytes';
    import { ConnectionInfo } from 'ethers/utils/web';
    export function hexlifyTransaction(transaction: TransactionRequest): any;
    export class JsonRpcSigner extends Signer {
        readonly provider: JsonRpcProvider;
        constructor(provider: JsonRpcProvider, address?: string);
        readonly address: string;
        getAddress(): Promise<string>;
        getBalance(blockTag?: BlockTag): Promise<BigNumber>;
        getTransactionCount(blockTag?: BlockTag): Promise<number>;
        sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse>;
        signMessage(message: Arrayish | string): Promise<string>;
        unlock(password: string): Promise<boolean>;
    }
    export class JsonRpcProvider extends Provider {
        readonly connection: ConnectionInfo;
        constructor(url?: ConnectionInfo | string, network?: Networkish);
        getSigner(address: string): JsonRpcSigner;
        listAccounts(): Promise<Array<string>>;
        send(method: string, params: any): Promise<any>;
        perform(method: string, params: any): Promise<any>;
        _startPending(): void;
        _stopPending(): void;
    }
}

declare module 'ethers/providers/web3-provider' {
    import { Networkish } from 'ethers/providers/networks';
    import { JsonRpcProvider } from 'ethers/providers/json-rpc-provider';
    export type Callback = (error: any, response: any) => void;
    export type AsyncProvider = {
        isMetaMask: boolean;
        host?: string;
        path?: string;
        sendAsync: (request: any, callback: Callback) => void;
    };
    export class Web3Provider extends JsonRpcProvider {
        readonly _web3Provider: AsyncProvider;
        constructor(web3Provider: AsyncProvider, network?: Networkish);
        send(method: string, params: any): Promise<any>;
    }
}

declare module 'ethers/utils/address' {
    import { BigNumber } from 'ethers/utils/bignumber';
    import { Arrayish } from 'ethers/utils/bytes';
    export function getAddress(address: string): string;
    export function getIcapAddress(address: string): string;
    export function getContractAddress(transaction: {
        from: string;
        nonce: Arrayish | BigNumber | number;
    }): string;
}

declare module 'ethers/utils/abi-coder' {
    import { Arrayish } from 'ethers/utils/bytes';
    export type CoerceFunc = (type: string, value: any) => any;
    export type ParamType = {
        name?: string;
        type: string;
        indexed?: boolean;
        components?: Array<any>;
    };
    export const defaultCoerceFunc: CoerceFunc;
    export type EventFragment = {
        type: string;
        name: string;
        anonymous: boolean;
        inputs: Array<ParamType>;
    };
    export type FunctionFragment = {
        type: string;
        name: string;
        constant: boolean;
        inputs: Array<ParamType>;
        outputs: Array<ParamType>;
        payable: boolean;
        stateMutability: string;
    };
    export function parseParamType(type: string): ParamType;
    export function parseSignature(fragment: string): EventFragment | FunctionFragment;
    export class AbiCoder {
        readonly coerceFunc: CoerceFunc;
        constructor(coerceFunc?: CoerceFunc);
        encode(types: Array<string | ParamType>, values: Array<any>): string;
        decode(types: Array<string | ParamType>, data: Arrayish): any;
    }
    export const defaultAbiCoder: AbiCoder;
}

declare module 'ethers/utils/base64' {
    import { Arrayish } from 'ethers/utils/bytes';
    export function decode(textData: string): Uint8Array;
    export function encode(data: Arrayish): string;
}

declare module 'ethers/utils/bignumber' {
    import { Arrayish } from 'ethers/utils/bytes';
    export type BigNumberish = BigNumber | string | number | Arrayish;
    export class BigNumber {
        constructor(value: BigNumberish);
        fromTwos(value: number): BigNumber;
        toTwos(value: number): BigNumber;
        add(other: BigNumberish): BigNumber;
        sub(other: BigNumberish): BigNumber;
        div(other: BigNumberish): BigNumber;
        mul(other: BigNumberish): BigNumber;
        mod(other: BigNumberish): BigNumber;
        pow(other: BigNumberish): BigNumber;
        maskn(value: number): BigNumber;
        eq(other: BigNumberish): boolean;
        lt(other: BigNumberish): boolean;
        lte(other: BigNumberish): boolean;
        gt(other: BigNumberish): boolean;
        gte(other: BigNumberish): boolean;
        isZero(): boolean;
        toNumber(): number;
        toString(): string;
        toHexString(): string;
    }
    export function isBigNumber(value: any): boolean;
    export function bigNumberify(value: BigNumberish): BigNumber;
    export const ConstantNegativeOne: BigNumber;
    export const ConstantZero: BigNumber;
    export const ConstantOne: BigNumber;
    export const ConstantTwo: BigNumber;
    export const ConstantWeiPerEther: BigNumber;
}

declare module 'ethers/utils/bytes' {
    /**
      *  Conversion Utilities
      *
      */
    import { BigNumber } from 'ethers/utils/bignumber';
    import { Signature } from 'ethers/utils/secp256k1';
    export type Arrayish = string | ArrayLike<number>;
    export function isArrayish(value: any): boolean;
    export function arrayify(value: Arrayish | BigNumber): Uint8Array;
    export function concat(objects: Array<Arrayish>): Uint8Array;
    export function stripZeros(value: Arrayish): Uint8Array;
    export function padZeros(value: Arrayish, length: number): Uint8Array;
    export function isHexString(value: any, length?: number): boolean;
    export function hexlify(value: Arrayish | BigNumber | number): string;
    export function hexDataLength(data: string): number;
    export function hexDataSlice(data: string, offset: number, length?: number): string;
    export function hexStripZeros(value: string): string;
    export function hexZeroPad(value: string, length: number): string;
    export function splitSignature(signature: Arrayish): Signature;
    export function joinSignature(signature: Signature): string;
}

declare module 'ethers/utils/hash' {
    import { Arrayish } from 'ethers/utils/bytes';
    export function namehash(name: string): string;
    export function id(text: string): string;
    export function hashMessage(message: Arrayish | string): string;
}

declare module 'ethers/utils/keccak256' {
    import { Arrayish } from 'ethers/utils/bytes';
    export function keccak256(data: Arrayish): string;
}

declare module 'ethers/utils/sha2' {
    import { Arrayish } from 'ethers/utils/bytes';
    export function sha256(data: Arrayish): string;
    export function sha512(data: Arrayish): string;
}

declare module 'ethers/utils/solidity' {
    export function pack(types: Array<string>, values: Array<any>): string;
    export function keccak256(types: Array<string>, values: Array<any>): string;
    export function sha256(types: Array<string>, values: Array<any>): string;
}

declare module 'ethers/utils/random-bytes' {
    export function randomBytes(length: number): Uint8Array;
}

declare module 'ethers/utils/properties' {
    export function defineReadOnly(object: any, name: string, value: any): void;
    export function defineFrozen(object: any, name: string, value: any): void;
    export function resolveProperties(object: any): Promise<any>;
    export function shallowCopy(object: any): any;
    export function jsonCopy(object: any): any;
}

declare module 'ethers/utils/rlp' {
    import { Arrayish } from 'ethers/utils/bytes';
    export function encode(object: any): string;
    export function decode(data: Arrayish): any;
}

declare module 'ethers/utils/utf8' {
    import { Arrayish } from 'ethers/utils/bytes';
    export enum UnicodeNormalizationForm {
        current = "",
        NFC = "NFC",
        NFD = "NFD",
        NFKC = "NFKC",
        NFKD = "NFKD"
    }
    export function toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array;
    export function toUtf8String(bytes: Arrayish): string;
}

declare module 'ethers/utils/units' {
    import { BigNumber, BigNumberish } from 'ethers/utils/bignumber';
    export function formatUnits(value: BigNumberish, unitType?: string | number, options?: any): string;
    export function parseUnits(value: string, unitType?: string | number): BigNumber;
    export function formatEther(wei: BigNumberish, options: any): string;
    export function parseEther(ether: string): BigNumber;
}

declare module 'ethers/utils/web' {
    export type ConnectionInfo = {
        url: string;
        user?: string;
        password?: string;
        allowInsecure?: boolean;
    };
    export type ProcessFunc = (value: any) => any;
    export function fetchJson(connection: string | ConnectionInfo, json: string, processFunc: ProcessFunc): Promise<any>;
}

declare module 'ethers/utils/transaction' {
    import { BigNumber, BigNumberish } from 'ethers/utils/bignumber';
    import { Arrayish } from 'ethers/utils/bytes';
    import { Signature } from 'ethers/utils/secp256k1';
    export type UnsignedTransaction = {
        to?: string;
        nonce?: number;
        gasLimit?: BigNumberish;
        gasPrice?: BigNumberish;
        data?: Arrayish;
        value?: BigNumberish;
        chainId?: number;
    };
    export interface Transaction {
        hash?: string;
        to?: string;
        from?: string;
        nonce: number;
        gasLimit: BigNumber;
        gasPrice: BigNumber;
        data: string;
        value: BigNumber;
        chainId: number;
        r?: string;
        s?: string;
        v?: number;
    }
    export type SignDigestFunc = (digest: Arrayish) => Signature;
    export function sign(transaction: UnsignedTransaction, signDigest: SignDigestFunc): string;
    export function parse(rawTransaction: Arrayish): Transaction;
}

declare module 'ethers/wallet/wallet' {
    import { HDNode } from 'ethers/wallet/hdnode';
    import { ProgressCallback } from 'ethers/wallet/secret-storage';
    import { SigningKey } from 'ethers/wallet/signing-key';
    import { BlockTag, Provider, TransactionRequest, TransactionResponse } from 'ethers/providers/provider';
    import { Wordlist } from 'ethers/wordlists/wordlist';
    import { BigNumber } from 'ethers/utils/bignumber';
    import { Arrayish } from 'ethers/utils/bytes';
    export abstract class Signer {
            provider?: Provider;
            abstract getAddress(): Promise<string>;
            abstract signMessage(transaction: Arrayish | string): Promise<string>;
            abstract sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse>;
    }
    export class Wallet extends Signer {
            readonly provider: Provider;
            constructor(privateKey: SigningKey | HDNode | Arrayish, provider?: Provider);
            readonly address: string;
            readonly mnemonic: string;
            readonly path: string;
            readonly privateKey: string;
            /**
                *  Create a new instance of this Wallet connected to provider.
                */
            connect(provider: Provider): Wallet;
            getAddress(): Promise<string>;
            sign(transaction: TransactionRequest): Promise<string>;
            signMessage(message: Arrayish | string): Promise<string>;
            getBalance(blockTag?: BlockTag): Promise<BigNumber>;
            getTransactionCount(blockTag?: BlockTag): Promise<number>;
            sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse>;
            encrypt(password: Arrayish | string, options: any, progressCallback: ProgressCallback): Promise<string>;
            /**
                *  Static methods to create Wallet instances.
                */
            static createRandom(options: any): Wallet;
            static fromEncryptedJson(json: string, password: Arrayish, progressCallback: ProgressCallback): Promise<Wallet>;
            static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet;
            /**
                *  Determine if this is an encryped JSON wallet.
                */
            static isEncryptedWallet(json: string): boolean;
            /**
                *  Verify a signed message, returning the address of the signer.
                */
            static verifyMessage(message: Arrayish | string, signature: string): string;
    }
}

declare module 'ethers/wallet/hdnode' {
    import { Wordlist } from 'ethers/wordlists/wordlist';
    import { Arrayish } from 'ethers/utils/bytes';
    export const defaultPath = "m/44'/60'/0'/0/0";
    export class HDNode {
        readonly privateKey: string;
        readonly publicKey: string;
        readonly mnemonic: string;
        readonly path: string;
        readonly chainCode: string;
        readonly index: number;
        readonly depth: number;
        /**
          *  This constructor should not be called directly.
          *
          *  Please use:
          *   - fromMnemonic
          *   - fromSeed
          */
        constructor(privateKey: Arrayish, chainCode: Uint8Array, index: number, depth: number, mnemonic: string, path: string);
        derivePath(path: string): HDNode;
    }
    export function fromMnemonic(mnemonic: string, wordlist?: Wordlist): HDNode;
    export function fromSeed(seed: Arrayish): HDNode;
    export function mnemonicToSeed(mnemonic: string, password?: string): string;
    export function mnemonicToEntropy(mnemonic: string, wordlist?: Wordlist): string;
    export function entropyToMnemonic(entropy: Arrayish, wordlist?: Wordlist): string;
    export function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean;
}

declare module 'ethers/wallet/signing-key' {
    import { Arrayish } from 'ethers/utils/bytes';
    import { HDNode } from 'ethers/wallet/hdnode';
    import { Signature } from 'ethers/utils/secp256k1';
    export class SigningKey {
        readonly privateKey: string;
        readonly publicKey: string;
        readonly address: string;
        readonly mnemonic: string;
        readonly path: string;
        constructor(privateKey: Arrayish | HDNode);
        signDigest(digest: Arrayish): Signature;
    }
    export function recoverAddress(digest: Arrayish, signature: Signature): string;
    export function computeAddress(key: string): string;
}

declare module 'ethers/wordlists/wordlist' {
    export abstract class Wordlist {
        locale: string;
        constructor(locale: string);
        abstract getWord(index: number): string;
        abstract getWordIndex(word: string): number;
        split(mnemonic: string): Array<string>;
        join(words: Array<string>): string;
    }
    export function register(lang: Wordlist): void;
}

declare module 'ethers/utils/secp256k1' {
    import { Arrayish } from 'ethers/utils/bytes';
    export const N: string;
    export interface Signature {
        r: string;
        s: string;
        recoveryParam: number;
        v?: number;
    }
    export class KeyPair {
        readonly privateKey: string;
        readonly publicKey: string;
        readonly compressedPublicKey: string;
        readonly publicKeyBytes: Uint8Array;
        constructor(privateKey: Arrayish);
        sign(digest: Arrayish): Signature;
    }
    export function recoverPublicKey(digest: Arrayish, signature: Signature): string;
    export function computePublicKey(key: Arrayish, compressed?: boolean): string;
    export function recoverAddress(digest: Arrayish, signature: Signature): string;
    export function computeAddress(key: string): string;
}

declare module 'ethers/wallet/secret-storage' {
    import { Arrayish } from 'ethers/utils/bytes';
    import { SigningKey } from 'ethers/wallet/signing-key';
    export interface ProgressCallback {
        (percent: number): void;
    }
    export function isCrowdsaleWallet(json: string): boolean;
    export function isValidWallet(json: string): boolean;
    export function decryptCrowdsale(json: string, password: Arrayish | string): SigningKey;
    export function decrypt(json: string, password: Arrayish, progressCallback?: ProgressCallback): Promise<SigningKey>;
    export type EncryptOptions = {
        iv?: Arrayish;
        entropy?: Arrayish;
        mnemonic?: string;
        path?: string;
        client?: string;
        salt?: Arrayish;
        uuid?: string;
        scrypt?: {
            N?: number;
            r?: number;
            p?: number;
        };
    };
    export function encrypt(privateKey: Arrayish | SigningKey, password: Arrayish | string, options?: EncryptOptions, progressCallback?: ProgressCallback): Promise<string>;
}

